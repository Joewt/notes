# 函数声明

### 预备知识

理解如下语句
```
(*(void(*)())0)();
```
理解这个语句的含义先了解以下内容  
构造这类表达式只有一条简单的规则:  
- 按照使用方式来声明  

任何C变量的声明都由两部分组成:  
- 类型以及一组类似表达式的声明符(declarator)。声明符从表面上看与表达式有些类似，对它求值应该返回一个声明中给定类型的结果  

最简单的声明符就是单个变量:  
```
float f, g;
```
这个声明的含义:   
- 当对其求值时，表达式f和g的类型为浮点数类型(float)。

因为声明符与表达式的相似，所以我们也可以在声明符中任意使用括号:  
```
float ((f));
```
这个声明的含义是:  
- 当对其求值时，((f))的类型为浮点型，由此可以推知，f也是浮点类型。

同样的逻辑也适合用于函数和指针类型的声明，例如:  
```
float ff();
```
这个声明的含义是:  
- 表达式ff()求值结果是一个浮点数，也就是说，ff是一个返回值为浮点数类型的函数。  

类似的:
```
float *pf;
```

- 这个声明的含义是*pf是一个浮点数，也就是说，pf是一个指向浮点数的指针  

以上形式组合起来:  
```
float *g(), (*h)();
```
- 表示`*g()`与`(*h)()`是浮点表达式。因为()结合优先级高于*,`*g()`也就是*(g()): g是一个函数，该函数的返回值类型为指向浮点数的指针。同理，h是一个函数指针，h所指向函数的返回值为浮点类型。  

一旦我们知道了如何声明一个给定类型的变量，那么该类型的类型转换符就很容易得到了:  只需要把声明中变量名和声明末尾的分好去掉，再将剩余的部分用一个括号整个“封装”起来即可。例如，如下声明
```
float (*h)();
```
- 表示h是一个指向返回值为浮点类型的函数的指针，因此

```
(float (*h)()
```
- 表示一个“指向返回值为浮点类型的函数的指针”的类型转换符  

### 理解`(*(void(*)())0())`

有了以上的知识，我们分两步来分析表达式`(*(void(*)())0()`  
1. 假定变量是一个函数指针，那么如何调用fp所指向的函数呢? 调用方法如下:  
    ```
    (*fp)();
    ```
    因为fp是一个函数指针，那么*fp就是该指针所指向的函数，所以`(*fp)()`就是调用该函数的方式。  
    现在，剩下的问题就只是找到一个恰当的表达式来替代fp。

2. 如果C编译器能够理解我们大脑中对于类型的认识，那么我们可以这样写:
    ```
    (*0)();
    ```
    上式并不能生效，因为运算符*必须要一个指针来做操作数。并且，这个指针还应该是一个函数指针，这样经运算符*作用后的结果才能作为函数调用。因此，在上式中必须对0作类型转换，转换后的类型可以大致描述为：“指向返回值为void类型的函数的指针”  
    如果fp是一个指向返回值为void类型的函数的指针，那么`(*fp)()`的值为void，fp的声明如下
    ```
    void (*fp)();
    ```
    可以用下式来完成调用存储位置为0的子例程：
    ```
    void (*fp)();
    (*fp)();
    ```
    这种写法的代价是多声明了一个“哑”变量


知道如何声明一个变量，也就自然知道如何对一个常数进行类型转换，将其转型为该变量的类型：只需要在变量声明中将变量名去掉即可。  
将常数0转型为”指向返回值为void的函数的指针“类型，可以这样写：
```
(void (*)())0))
```
可以用`(void (*)())()`来代替fp，得到：
```
(*(void (*)())0)();
```
末尾的分号使得表达式成为一个语句。  
作者在解决这个问题的时候还没有typedef声明。以下是用typedef表达：
```
typdef void (*funcptr)();
(*(fuuncptr)0)();
```
